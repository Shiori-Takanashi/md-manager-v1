<hr>

### 📝第24章：メモリリーク

* 不要オブジェクトへの参照の放置
* キャッシュ・クロージャが原因の例
* 遅延評価との関係性

### 📝第25章：`del` の効果

* 名前空間からの削除
* `gc` による最終的な回収
* 参照カウントが0になるまで残る

### 📝第26章：`getrefcount()` の実験

* 実験的に参照数を確認する方法
* `+1` されている理由
* 本質的な確認には `gc` が必要

### 📝第27章：`gc` と循環参照

* 参照カウントでは解決できないケース
* `gc.collect()` による手動回収
* `__del__()` の干渉と副作用

### 📝第28章：グローバル共有の危険

* 参照の共有による不具合
* `global` の使用を避ける理由
* 安全な共有設計：関数間依存の抑制

### 📝第29章：スレッドと参照

* 複数スレッドによる同一参照の競合
* `threading.Lock()` などの制御
* 不変設計の導入による回避

### 📝第30章：キャッシュ設計

* オブジェクトの再利用戦略
* `lru_cache` / `dict` によるキャッシュ
* 再生成コストとのトレードオフ

<hr>