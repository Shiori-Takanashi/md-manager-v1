Counter({'\n': 326})

```
---\n
title: Python_Foundation_\n
keyword:\n
created: 2025-08-03 03:24\n
modified: 2025-08-03 03:24\n
vault: technology\n
catergory: Language\n
language: Python\n
area: Foundation\n
identify:\n
type:\n
role:\n
order:\n
---\n
\n
# 📢Python_Reference_Lesson_Index\n
\n
---\n
\n
## 📍 第01部：参照の基礎\n
\n
\n
\n
### 📝第01章：変数は名前\n
\n
* 「箱」モデルの否定\n
* 名前とオブジェクトの分離\n
* `id()` 関数の使用\n
\n
\n
\n
### 📝第02章：`id()` の意味\n
\n
* `id(obj)` は何を返すのか\n
* メモリアドレスとの関係\n
* 参照の可視化手段としての利用\n
\n
\n
\n
### 📝第03章：`is` ・`==`\n
\n
* 等価性 vs 同一性\n
* `is` を使うべきケース\n
* `None` との比較での使用例\n
\n
\n
\n
### 📝第04章：イミュータブル最適化\n
\n
* 整数・文字列などのインターン\n
* 小さい整数の再利用\n
* 暗黙の最適化と副作用の危険性\n
\n
\n
\n
### 📝第05章：代入と共有\n
\n
* `a = b` による共有\n
* 書き換えが双方に影響する場合\n
* `a[:] = ...` との違い\n
\n
\n
\n
### 📝第06章：デフォルト引数\n
\n
* `def f(x=[])` の落とし穴\n
* デフォルト引数が共有される理由\n
* 対処法： `None` + 初期化\n
\n
\n
\n
### 📝第07章：引数と参照\n
\n
* 実引数と仮引数の実体\n
* ミュータブル型を渡したときの挙動\n
* 関数内での再代入は外部に影響しない理由\n
\n
\n
\n
### 📝第08章：破壊的操作の影響\n
\n
* `.append()` などの操作\n
* 外部変数の意図しない変更\n
* 予防策と設計上の配慮\n
\n
\n
\n
### 📝第09章：浅いコピー\n
\n
* オブジェクトの第一階層のみをコピー\n
* ネスト構造がある場合の危険性\n
* 参照が混在するケースの例\n
\n
\n
\n
### 📝第10章：深いコピー\n
\n
* 入れ子構造全体を複製\n
* 循環参照の扱い\n
* `memo` による再訪問制御\n
\n
---\n
\n
## 📍 第02部：典型バグとその背景\n
\n
---\n
\n
### 📝第11章：`[[]] * 3` の罠\n
\n
* 同一リストの複製による共有\n
* インデックスでの変更が全体に波及\n
* 正しいリスト生成法との比較\n
\n
\n
\n
### 📝第12章：辞書と参照\n
\n
* 値の共有によるバグの発生\n
* `dict.copy()` の挙動\n
* 変更の影響範囲を限定する方法\n
\n
\n
\n
### 📝第13章：多重構造\n
\n
* ネストされたリスト・辞書の影響範囲\n
* 表層と深層の切り分け\n
* 再帰的な確認と保守性\n
\n
\n
\n
### 📝第14章：クラス属性\n
\n
* クラス変数とインスタンス変数の違い\n
* ミュータブル型の落とし穴\n
* `__init__` での個別生成の必要性\n
\n
\n
\n
### 📝第15章：初期値の共有\n
\n
* `self.items = []` を避けるべき位置\n
* クラス属性で初期化した場合の副作用\n
* 意図しない全インスタンス共有の事例\n
\n
\n
\n
### 📝第16章：操作の副作用\n
\n
* `.append()` vs `+`\n
* `.update()` vs `{**dict1, **dict2}`\n
* 関数の副作用を設計に明示する意義\n
\n
\n
\n
### 📝第17章：イテレータ状態\n
\n
* ジェネレータはオブジェクトである\n
* 状態の保存と共有\n
* `for` 文で使いまわすことのリスク\n
\n
\n
\n
### 📝第18章：`None` による切断\n
\n
* `x = None` による参照解除\n
* `is None` を使うべき理由\n
* 実体がないことを表す安全な方法\n
\n
---\n
\n
## 📍 第03部：設計とテスト\n
\n
---\n
\n
### 📝第19章：参照と設計方針\n
\n
* 値渡しスタイル vs 参照渡しスタイル\n
* 読みやすさと意図の明示\n
* 状態管理を明確化する方法\n
\n
\n
\n
### 📝第20章：副作用の明示\n
\n
* ミュータブルな引数に影響を与える場合\n
* 関数仕様書・docstringでの注意喚起\n
* テスト容易性との関係\n
\n
\n
\n
### 📝第21章：`assertIs` の活用\n
\n
* unittestでの参照の確認\n
* `is` を使った厳密比較\n
* 参照バグの早期検知\n
\n
\n
\n
### 📝第22章：動的参照操作\n
\n
* 名前空間の辞書としての活用\n
* 実用上のリスクと可読性\n
* Pythonic とは言い難い構成例\n
\n
\n
\n
### 📝第23章：参照を断つ設計\n
\n
* 疎結合・副作用ゼロ設計\n
* 関数型スタイルの活用\n
* テスト性・保守性の向上\n
\n
---\n
\n
## 📍 第04部：メモリと共有構造\n
\n
---\n
\n
### 📝第24章：メモリリーク\n
\n
* 不要オブジェクトへの参照の放置\n
* キャッシュ・クロージャが原因の例\n
* 遅延評価との関係性\n
\n
\n
\n
### 📝第25章：`del` の効果\n
\n
* 名前空間からの削除\n
* `gc` による最終的な回収\n
* 参照カウントが0になるまで残る\n
\n
\n
\n
### 📝第26章：`getrefcount()` の実験\n
\n
* 実験的に参照数を確認する方法\n
* `+1` されている理由\n
* 本質的な確認には `gc` が必要\n
\n
\n
\n
### 📝第27章：`gc` と循環参照\n
\n
* 参照カウントでは解決できないケース\n
* `gc.collect()` による手動回収\n
* `__del__()` の干渉と副作用\n
\n
\n
\n
### 📝第28章：グローバル共有の危険\n
\n
* 参照の共有による不具合\n
* `global` の使用を避ける理由\n
* 安全な共有設計：関数間依存の抑制\n
\n
\n
\n
### 📝第29章：スレッドと参照\n
\n
* 複数スレッドによる同一参照の競合\n
* `threading.Lock()` などの制御\n
* 不変設計の導入による回避\n
\n
\n
\n
### 📝第30章：キャッシュ設計\n
\n
* オブジェクトの再利用戦略\n
* `lru_cache` / `dict` によるキャッシュ\n
* 再生成コストとのトレードオフ\n
\n
---\n
\n
## 📍 第05部：参照の特殊構造\n
\n
---\n
\n
### 📝第31章：クロージャと変数束縛\n
\n
* 関数がスコープ外の変数を記憶する仕組み\n
* `def outer(): def inner():` のような構造\n
* 参照として残る名前とそのリスク\n
\n
\n
\n
### 📝第32章：`nonlocal` の役割と設計\n
\n
* `nonlocal` による外側変数への代入\n
* クロージャ内部での状態更新パターン\n
* 再代入の明示によるバグ予防\n
\n
\n
\n
### 📝第33章：lambda の参照落とし穴\n
\n
* `lambda` 式が評価時に変数を参照する理由\n
* `for` ループでの `lambda` 誤用パターン\n
* リスト内包と同時使用時の注意点\n
\n
\n
\n
### 📝第34章：デフォルト引数による参照固定\n
\n
* `lambda x=i:` のような固定値の技法\n
* 評価タイミングの違いを利用した工夫\n
* 暗黙の束縛を明示する設計方針\n
\n
\n
\n
### 📝第35章：型ヒントによる意図の明示\n
\n
* `list[int]` vs `tuple[int, ...]` の選択\n
* ミュータブルとイミュータブルの設計指針\n
* `dict[str, Any]` の具体的使用事例\n
\n
\n
\n
### 📝第36章：`Final` と不変設計\n
\n
* `from typing import Final` の基本\n
* 共有参照での意図しない書き換え防止\n
* `Final` による設計上の契約の明示\n
\n
---\n

```